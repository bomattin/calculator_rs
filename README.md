# About this Branch
When we were assigned this project, we were asked to code it in C++ or Java. I am
a masochist. I really, really wanted to do the project in Rust, since I felt that
the project was a natural fit for the language, but my professor politely
affirmed his above request. Naturally I did it in both.

Each source file in this branch is _"overdocumented"_, meaning it contains much
more documentation than a reasonable person _familiar with the language_ would
necessarily need. It is intended to be read by beginners to the Rust language in
order to help explain the syntax and decisions made in implementing this
particular solution.

## The Problem:

You will write a calculator program in 3 phases. The idea is to learn about compiler contsruction, only on a small enough scale we can complete it in half a semester.

### Phase 1: Scanner (30 points)
Write a program that takes an input data file (see below for the format) and prints out a list of tokens (one per line) together with the token type. If the input includes characters not consistent with a token, stop and print an error message.
The scanner should process one line at a time. For each line of text, it should create an array of tokens found on that line. Processing can start over on a new input line of text. Note that a line can be blank or empty.

### Phase 2: Parser (40 points)
Write a recursive-descent parser to verify the grammar for each line of the input file (see section 2.3.1).
Using the array of tokens generated by your program from phase 1 (you'll want to include that code, perhaps as a .h file) you'll create a function to parse each production from the calculator grammar (see below). If a token fails to match, or you run out of tokens before finishing, print an error message and stop. Otherwise, simply output "correctly parsed" or something similar.

### Phase 3: Semantic Analyzer (30 points)
Add semantics to the grammar parsed in phase 2. This means, for example, you must perform the addition for the + production, and each function in the recursive descent parser should add a reference argument that returns the value of that production/expression. Maintain an array of 26 integers to hold the values of the variables A-Z (use something like register[c-'A']) to hold the results of assignments. These should all be zero to begin with.
After parsing an expression or assignment for the line of input, print out the value computed.

## Token Types

The scanner must recognize the following tokens:

Integer constant: one or more decimal digits
Arithmetic operators: +, -, \*, /, %, ^
Assignment operator: =
Semicolon: ;
Variable name: a single letter (ignore case)
The word "quit" (ignore case)


## Example output
For the given input:

`+ - 34 ; quit a 3 3 - - 1 * ^ 7`

```
Addition
Subtraction
Integer(34)
Terminator
Quit
Variable('a')
Integer(3)
Integer(3)
Subtraction
Subtraction
Integer(1)
Multiplication
Exponent
Integer(7)
```
